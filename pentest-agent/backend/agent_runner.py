from __future__ import annotations

import os
from datetime import datetime
from pathlib import Path

import requests

from backend.environment import ACTIONS, PentestEnvironment
from backend.exploit_stub import execute_exploit_stub
from backend.persistence import Persistence, get_model_path
from rl.checkpoints import load_checkpoint, save_checkpoint
from rl.replay_buffer import Experience
from rl.trainer import DQNTrainer


class AgentRunner:
    def __init__(self, backend_url: str = "http://127.0.0.1:8000") -> None:
        self.backend_url = backend_url
        self.api_key = os.getenv("PENTEST_AGENT_API_KEY", "dev-internal-key")
        self.headers = {"x-api-key": self.api_key}
        self.env = PentestEnvironment()
        self.db = Persistence()
        self.trainer = DQNTrainer(state_size=5, action_size=len(ACTIONS))
        self.episode = 0
        self._load_if_available()

    def _load_if_available(self) -> None:
        latest = self.db.latest_checkpoint()
        if latest and latest.get("model_path") and Path(latest["model_path"]).exists():
            ckpt = load_checkpoint(Path(latest["model_path"]), self.trainer.policy_net, self.trainer.optimizer)
            self.trainer.epsilon = float(ckpt.get("epsilon", 1.0))
            self.episode = int(ckpt.get("episode", 0))

    def run_episode(self, target_id: int, ip: str) -> None:
        self.env.register_target(target_id, ip)
        for _ in range(3):
            state = self.env.state_to_vector(target_id)
            action_idx, q_values = self.trainer.select_action(state)
            action_name, action_type = ACTIONS[action_idx]

            if action_type == "exploitation":
                auth_payload = {
                    "target_id": target_id,
                    "ip": ip,
                    "vuln_id": f"SIM-{target_id}",
                    "action": action_name,
                    "q_values": q_values,
                    "timestamp": datetime.utcnow().isoformat(),
                }
                resp = requests.post(f"{self.backend_url}/request_authorization", json=auth_payload, headers=self.headers, timeout=10)
                auth_id = resp.json()["auth_id"]
                pending = requests.get(f"{self.backend_url}/pending_authorizations", headers=self.headers, timeout=10).json()["items"]
                decision = next((p["decision"] for p in pending if p["id"] == auth_id), "pending")
                if decision != "allow":
                    reward = self.env.apply_exploit_result(target_id, success=False, denied=True)
                    result = "denied_or_pending"
                else:
                    sim = execute_exploit_stub(ip, action_name)
                    reward = self.env.apply_exploit_result(target_id, success=sim["success"])
                    result = "success" if sim["success"] else "failed"
            else:
                obs, reward = self.env.step_passive(target_id, action_name)
                result = obs["phase"]

            next_state = self.env.state_to_vector(target_id)
            self.trainer.remember(Experience(state, action_idx, reward, next_state, False))
            self.trainer.train_step()
            self.db.log_action(target_id, action_name, action_type, result, reward)

        self.episode += 1
        ckpt_path = get_model_path()
        # Persist training using state_dict + optimizer state for safe resume.
        save_checkpoint(ckpt_path, self.trainer.policy_net, self.trainer.optimizer, self.trainer.epsilon, self.episode)
        self.db.add_checkpoint(self.episode, self.trainer.epsilon, str(ckpt_path), self.db.metrics()["avg_reward"])


if __name__ == "__main__":
    target_id = int(os.getenv("TARGET_ID", "1"))
    ip = os.getenv("TARGET_IP", "127.0.0.1")
    AgentRunner().run_episode(target_id=target_id, ip=ip)
