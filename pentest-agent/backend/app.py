from __future__ import annotations

import os
from pathlib import Path
from typing import Optional

from fastapi import Depends, FastAPI, Header, HTTPException
from pydantic import BaseModel

from backend.persistence import Persistence


API_KEY = os.getenv("PENTEST_AGENT_API_KEY", "dev-internal-key")
AUTH_CONFIRM_TOKEN = os.getenv("AUTH_TOKEN", "I_HAVE_WRITTEN_PERMISSION")

app = FastAPI(title="Pentest Agent Backend", version="0.1.0")
db = Persistence()


def require_key(x_api_key: str = Header(...)) -> None:
    if x_api_key != API_KEY:
        raise HTTPException(status_code=401, detail="Invalid API key")


class TargetIn(BaseModel):
    ip: str
    auth_token: str
    scope_path: Optional[str] = None


class VulnReport(BaseModel):
    target_id: int
    vuln_id: str
    severity: str
    description: str
    suggested_action: str
    q_value: float = 0.0


class AuthorizationReq(BaseModel):
    target_id: int
    ip: str
    vuln_id: str
    action: str
    q_values: list[float]
    timestamp: str


class DecisionIn(BaseModel):
    auth_id: int
    decision: str
    user: str
    comment: str = ""


@app.post("/targets", dependencies=[Depends(require_key)])
def create_target(payload: TargetIn):
    if payload.auth_token != AUTH_CONFIRM_TOKEN:
        raise HTTPException(status_code=400, detail="AUTH_TOKEN mismatch")
    if payload.scope_path and not Path(payload.scope_path).exists():
        raise HTTPException(status_code=400, detail="scope.txt path not found")
    target_id = db.create_target(payload.ip, payload.auth_token, payload.scope_path)
    return {"target_id": target_id, "status": "created"}


@app.get("/targets/{target_id}", dependencies=[Depends(require_key)])
def get_target(target_id: int):
    target = db.get_target(target_id)
    if not target:
        raise HTTPException(status_code=404, detail="Target not found")
    return target


@app.post("/report_vuln", dependencies=[Depends(require_key)])
def report_vuln(payload: VulnReport):
    db.add_vulnerability(payload.model_dump())
    return {"ok": True}


@app.post("/request_authorization", dependencies=[Depends(require_key)])
def request_authorization(payload: AuthorizationReq):
    auth_id = db.create_authorization(payload.model_dump())
    return {"auth_id": auth_id, "decision": "pending"}


@app.get("/pending_authorizations", dependencies=[Depends(require_key)])
def pending_authorizations():
    return {"items": db.pending_authorizations()}


@app.post("/decide", dependencies=[Depends(require_key)])
def decide(payload: DecisionIn):
    if payload.decision not in {"allow", "deny"}:
        raise HTTPException(status_code=400, detail="decision must be allow|deny")
    db.decide_authorization(payload.auth_id, payload.decision, payload.user, payload.comment)
    return {"ok": True}


@app.get("/metrics", dependencies=[Depends(require_key)])
def metrics():
    return db.metrics()


@app.get("/health")
def health():
    return {"ok": True}
