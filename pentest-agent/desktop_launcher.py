from __future__ import annotations

import inspect
import os
import signal
import socket
import sys
import threading
import time
import webbrowser
from pathlib import Path

import requests
import uvicorn

BACKEND_HOST = "127.0.0.1"
BACKEND_PORT = 8000
DASHBOARD_HOST = "127.0.0.1"
DASHBOARD_PORT = 8501


def _project_root() -> Path:
    if getattr(sys, "frozen", False):
        return Path(sys._MEIPASS)  # type: ignore[attr-defined]
    return Path(__file__).resolve().parent


def _wait_for_http(url: str, timeout: float = 60.0) -> None:
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            resp = requests.get(url, timeout=1.5)
            if resp.status_code < 500:
                return
        except requests.RequestException:
            pass
        time.sleep(0.5)
    raise TimeoutError(f"Service did not become ready: {url}")


def _backend_thread(stop_event: threading.Event) -> None:
    config = uvicorn.Config(
        "backend.app:app",
        host=BACKEND_HOST,
        port=BACKEND_PORT,
        log_level="info",
        reload=False,
    )
    server = uvicorn.Server(config)

    def stopper() -> None:
        stop_event.wait()
        server.should_exit = True

    threading.Thread(target=stopper, daemon=True).start()
    server.run()


def _streamlit_thread(root: Path) -> None:
    from streamlit.web import bootstrap

    script_path = str(root / "dashboard" / "app.py")
    flag_options = {
        "server.address": DASHBOARD_HOST,
        "server.port": DASHBOARD_PORT,
        "server.headless": True,
        "browser.gatherUsageStats": False,
    }

    run_sig = inspect.signature(bootstrap.run)
    if "is_hello" in run_sig.parameters:
        bootstrap.run(script_path, is_hello=False, args=[], flag_options=flag_options)
    else:
        bootstrap.run(script_path, "", [], flag_options)


def _reserve_port(host: str, port: int) -> None:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.settimeout(1)
        if sock.connect_ex((host, port)) == 0:
            raise RuntimeError(f"Port {port} is already in use on {host}")


def main() -> None:
    root = _project_root()
    os.environ["PYTHONPATH"] = str(root)

    _reserve_port(BACKEND_HOST, BACKEND_PORT)
    _reserve_port(DASHBOARD_HOST, DASHBOARD_PORT)

    stop_event = threading.Event()
    backend = threading.Thread(target=_backend_thread, args=(stop_event,), daemon=True)
    backend.start()
    _wait_for_http(f"http://{BACKEND_HOST}:{BACKEND_PORT}/health")

    dashboard = threading.Thread(target=_streamlit_thread, args=(root,), daemon=True)
    dashboard.start()
    _wait_for_http(f"http://{DASHBOARD_HOST}:{DASHBOARD_PORT}/_stcore/health")

    webbrowser.open(f"http://{DASHBOARD_HOST}:{DASHBOARD_PORT}", new=1)

    def _shutdown(*_: object) -> None:
        stop_event.set()

    signal.signal(signal.SIGINT, _shutdown)
    if hasattr(signal, "SIGTERM"):
        signal.signal(signal.SIGTERM, _shutdown)

    try:
        while not stop_event.is_set():
            time.sleep(0.5)
            if not backend.is_alive() or not dashboard.is_alive():
                break
    finally:
        stop_event.set()
        time.sleep(1)


if __name__ == "__main__":
    main()
